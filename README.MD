
# Android Studio y Kotlin
# Propietaria
Andrea Santana L贸pez
## Kotlin playground
https://play.kotlinlang.org/
## Bases de Programaci贸n y Comienzos de Kotlin
Un programa como una serie de instrucciones para que una computadora o un dispositivo m贸vil realicen una acci贸n, como mostrar un mensaje a un usuario o calcular el costo de los art铆culos en un carrito de compras. Las instrucciones paso a paso para lo que la computadora debe hacer se llama c贸digo.Para escribir y editar tu c贸digo, debes usar una herramienta llamada editor de c贸digo para los codelabs se usar谩 un editor de c贸digo interactivo llamado Playground de Kotlin
El primer programa que todo inform谩tico hace es imprimir "Hola mundo" por lo que primero que ver茅 es como realizar un "Hola Mundo" en Kotlin.
```
fun main() {
    println("Hello, world!!!")
}
```
Aqu铆 tenemos una funci贸n llamada main que utiliza el comando println para mostrar el mensaje en la consola de comandos "CMD" en windows CLI en Linux/Mac.
## 驴Qu茅 es Kotlin?
Podemos decir que kotlin es un lenguaje compilado ya que necesita un compilador
## Recomendaciones de estilo de Kotlin
A continuaci贸n, se incluyen algunas de las recomendaciones de la gu铆a de estilo para lo que aprendiste en Kotlin hasta el momento:

Los nombres de las funciones deben seguir la convenci贸n de may煤sculas mediales y deben ser verbos o frases verbales.
Cada sentencia debe estar en su propia l铆nea.
La llave de apertura debe aparecer al final de la l铆nea donde comienza la funci贸n.
Debe haber un espacio antes de la llave de apertura.
El cuerpo de la funci贸n debe tener una sangr铆a de 4 espacios. No uses caracteres de tabulaci贸n para aplicar sangr铆a al c贸digo. Escribe 4 espacios.
La llave de cierre se encuentra en su propia l铆nea despu茅s de la 煤ltima l铆nea de c贸digo del cuerpo de la funci贸n. La llave de cierre debe alinearse con la palabra clave fun al comienzo de la funci贸n.

## Variables
En la programaci贸n inform谩tica, existe el concepto de variable, que es un contenedor para un 煤nico dato. Puedes visualizarla como una caja que contiene un valor. Esa caja tiene una etiqueta, que es el nombre de la variable. Si te refieres a la caja por su nombre, tendr谩s acceso al valor que contiene.
### Tipos de variables
!["Tipo de datos"](./images/Datas.png)
Existe tambi茅n un tipo llamado null

### 驴C贸mo defines una variable?
Cuando defines una variable, le asignas un nombre para identificarla de manera 煤nica. Tambi茅n debes decidir qu茅 tipo de datos puede contener mediante la especificaci贸n del tipo de datos. Por 煤ltimo, puedes proporcionar un valor inicial que se almacenar谩 en la variable, pero es opcional.
### Declaraci贸n de una variable como ejemplo
```
val count: Int = 2
```

Para declarar variables anulables se le pone al tipo un interrogante al lado por ejemplo --> var favoriteActor: String? = "Sandra Oh"
## 驴C贸mo se comenta?
Utlizando dos barras diagonales (//) como comentario simple y /**/ como comentario de m谩s de una l铆nea
## 驴Qu茅 es una funci贸n?
Una funci贸n es un segmento del programa que realiza una tarea espec铆fica. Tu programa podr铆a tener una o m谩s funciones.
Estas son las partes clave necesarias para definir una funci贸n:
                                                                1. La funci贸n necesita un nombre para que puedas llamarla m谩s tarde.
                                                                2. Tambi茅n puede requerir algunas entradas o informaci贸n que se debe proporcionar cuando se la llama. 
                                                                   La funci贸n usa estas entradas para lograr su prop贸sito. Pedir entradas es opcional, y algunas funciones no las piden.
                                                                3. La funci贸n tambi茅n tiene un cuerpo que contiene las instrucciones para realizar la tarea.

## Ejercicios del tutorial de kotlin de funciones y convenciones de estilo
1. [Ejercicios Kotlin](./CodelabTutorialKotlin/EjerciciosKotlin.kt)
2. [Conceptos b谩sicos Kotlin](./CodelabTutorialKotlin/ConceptosBasicos.kt)

## 驴Qu茅 es jetpackCompose?
Jetpack Compose es un kit de herramientas moderno para crear IUs de Android. Compose simplifica y acelera el desarrollo de IUs en Android con menos c贸digo, herramientas potentes y capacidades intuitivas de Kotlin. Con Compose, puedes compilar tu IU a partir de la definici贸n de un conjunto de funciones, llamadas funciones de componibilidad, que toman datos y describen elementos de la IU.
Funciones de componibilidad
Las funciones de componibilidad son los componentes b谩sicos de una IU en Compose. Una funci贸n de componibilidad cumple con lo siguiente:

1. Describe alguna parte de tu IU.
2. No devuelve nada.
3. Toma informaci贸n y genera lo que se muestra en la pantalla.

### Anotaciones
Las anotaciones son una forma de adjuntar informaci贸n adicional al c贸digo. Esta informaci贸n ayuda a herramientas como el compilador de Jetpack Compose y a otros desarrolladores a comprender el c贸digo de la app.
Para aplicar una anotaci贸n, se agrega un prefijo al nombre (la anotaci贸n) con el car谩cter @ al comienzo de la declaraci贸n en la que se har谩 la anotaci贸n. Se pueden anotar diferentes elementos de c贸digo, incluidas propiedades, funciones y clases. M谩s adelante en el curso, aprender谩s sobre las clases.
![Anotaciones](././images/anotaciones.png)
Ejemplo siguiente
```
// Example code, do not copy it over
@Json
val imgSrcUrl: String
@Volatile
private var INSTANCE: AppDatabase? = null
```
Las anotaciones pueden tomar par谩metros. Proporcionan informaci贸n adicional a las herramientas que las procesan. Los siguientes son algunos ejemplos de la anotaci贸n @Preview con y sin par谩metros.
![Anotaciones](././images/anotacionesconparams.png)
<br>
Ejemplo de anotaciones con parametros
<br>
![Anotaciones](././images/ejemplodeanotaciones.png)

## Funciones de componibilidad
La funci贸n de componibilidad tiene la anotaci贸n @Composable. Todas estas funciones deben tener esta anotaci贸n. La anotaci贸n informa al compilador de Compose que esta funci贸n est谩 dise帽ada para convertir datos en IU. Te recordamos que un compilador es un programa especial que toma el c贸digo que escribiste, lo analiza l铆nea por l铆nea y lo traduce a algo que la computadora puede comprender (lenguaje autom谩tico).Este fragmento de c贸digo es un ejemplo de una funci贸n simple de componibilidad a la que le pasan datos (el par谩metro de la funci贸n name) y los usa para renderizar un elemento de texto en la pantalla.
```
@Composable
fun Greeting(name: String) {
    Text(text = "Hello $name!")
}
```
Algunas notas sobre las funciones de componibilidad:

Jetpack Compose se basa en funciones de componibilidad. Estas funciones te permiten definir la IU de tu app de manera program谩tica describiendo c贸mo deber铆a verse, en lugar de enfocarse en el proceso de construcci贸n de la IU. Para crear una funci贸n de componibilidad, agrega la anotaci贸n @Composable al nombre de la funci贸n.

Estas funciones pueden aceptar par谩metros, que permiten que la l贸gica de la app describa o modifique la IU. En este caso, tu elemento de la IU acepta una String para que pueda saludar al usuario por su nombre.

La funci贸n de Compose que no devuelve nada y lleva la anotaci贸n @Composable DEBE tener un nombre con letra may煤scula inicial (pascal case). Esta es una convenci贸n de nomenclatura seg煤n la cual la primera letra de cada palabra de una palabra compuesta lleva may煤sculas. La diferencia entre este formato y el de may煤sculas mediales (camel case) es que, en el primer caso, todas las palabras se escriben con may煤scula inicial. En el segundo caso, la primera palabra puede estar en cualquiera de las dos opciones.
La funci贸n de Compose tiene las siguientes caracter铆sticas:
DEBE ser un sustantivo: DoneButton().
NO debe ser un verbo ni una frase verbal: DrawTextField().
NO debe ser una preposici贸n convertida en sustantivo: TextFieldWithLink().
NO debe ser un adjetivo: Bright().
NO debe ser un adverbio: Outside().
Los sustantivos PUEDEN estar precedidos por adjetivos descriptivos: RoundIcon().
<br>
Ejemplo de funciones componibles

```
// Do: This function is a descriptive PascalCased noun as a visual UI element
@Composable
fun FancyButton(text: String) {}


// Do: This function is a descriptive PascalCased noun as a non-visual element
// with presence in the composition
@Composable
fun BackButtonHandler() {}


// Don't: This function is a noun but is not PascalCased!
@Composable
fun fancyButton(text: String) {}


// Don't: This function is PascalCased but is not a noun!
@Composable
fun RenderFancyButton(text: String) {}


// Don't: This function is neither PascalCased nor a noun!
@Composable
fun drawProfileImage(image: ImageAsset) {}
```
## Panel Design de Android Studio
Android Studio te permite obtener una vista previa de las funciones de componibilidad dentro del IDE, en lugar de instalar la app en un emulador o dispositivo Android. Como aprendiste en la ruta de aprendizaje anterior, puedes obtener una vista previa de la apariencia de tu app en el panel Design de Android Studio.
La funci贸n de componibilidad debe proporcionar valores predeterminados para cualquier par谩metro para obtener una vista previa. Por este motivo, se recomienda no obtener una vista previa de la funci贸n Greeting() directamente. En su lugar, debes agregar otra funci贸n (BirthdayCardPreview() en este caso) que llame a la funci贸n Greeting() con un par谩metro adecuado.
```
@Preview(showBackground = true)
@Composable
fun BirthdayCardPreview() {
    HappyBirthdayTheme {
        Greeting("Android")
    }
}

```
## Jerarqu铆a de la IU
La jerarqu铆a de la IU se basa en la contenci贸n, es decir, un componente puede contener uno o m谩s componentes. A veces, se usan los t茅rminos superior y secundario. El contexto aqu铆 es que los elementos superiores de la IU contienen elementos secundarios de la IU, los cuales, a su vez, pueden contener elementos secundarios de la IU. En esta secci贸n, aprender谩s sobre los elementos componibles Column, Row y Box, que pueden actuar como elementos superiores de la IU.Los tres elementos de dise帽o est谩ndar b谩sicos en Compose son los elementos Column, Row y Box componibles. En el siguiente codelab, obtendr谩s m谩s informaci贸n sobre el elemento Box componible.Column, Row y Box son funciones de componibilidad, y toman contenido de este tipo como argumentos, por lo que puedes colocar elementos dentro de estos componentes de dise帽o. Por ejemplo, cada elemento secundario dentro de un elemento Row que admite composici贸n se coloca de forma horizontal uno al lado del otro en una fila.
![Jerarqu铆aUI](././images/JerarquiaUI.png)
```
// Don't copy.
Row {
    Text("First Column")
    Text("Second Column")
}
```
Estos elementos de texto se muestran uno al lado del otro en la pantalla, como se ve en esta imagen.

Los bordes azules son solo para fines de demostraci贸n y no se mostrar谩n.
![Jerarqu铆aUI](././images/JerarquiaUI2.png)

## Sintaxis de expresi贸n lambda final
En el fragmento de c贸digo anterior, observa que se usan llaves en lugar de par茅ntesis en la funci贸n de componibilidad Row. Esto se llama sintaxis de expresi贸n lambda final. M谩s adelante en el curso, aprender谩s sobre las lambdas y la sintaxis de expresi贸n lambda final en detalle. Por ahora, familiar铆zate con esta sintaxis de Compose de uso general.

Kotlin ofrece una sintaxis especial para pasar funciones como par谩metros a funciones cuando el 煤ltimo par谩metro es una funci贸n.
![lambda](././images/lambda.png)
Cuando pasas una funci贸n como ese par谩metro, puedes usar la sintaxis de expresi贸n lambda final. En lugar de colocar la funci贸n dentro de los par茅ntesis, puedes colocarla fuera de los par茅ntesis y entre llaves. Esta pr谩ctica es recomendada y com煤n en Compose, por lo que debes familiarizarte con la apariencia del c贸digo.

Por ejemplo, el 煤ltimo par谩metro en la funci贸n de componibilidad Row() es el par谩metro content, una funci贸n que describe los elementos secundarios de la IU. Supongamos que deseas crear una fila que contenga tres elementos de texto. Este c贸digo funcionar铆a, pero es muy engorroso usar el par谩metro con nombre para la expresi贸n lambda final:
```
Row(
    content = {
        Text("Some text")
        Text("Some more text")
        Text("Last text")
    }
)
```
Como el par谩metro content es el 煤ltimo de la firma de la funci贸n y pasas su valor como una expresi贸n lambda (por ahora, no hay problema si no sabes qu茅 es una lambda; solo familiar铆zate con la sintaxis), puedes quitar el par谩metro content y los par茅ntesis de la siguiente manera:
```
Row {
    Text("Some text")
    Text("Some more text")
    Text("Last text")
}
```
Apartado de inserci贸n de imagen y bases de compose  para 25/10/2025
Apartado de crear app de tarjetas desde 25/10 a 26/10

## C贸mo agregar una imagen a tu proyecto

En esta tarea, descargar谩s una imagen de Internet y la agregar谩s a la app de Happy Birthday.
1. Abre la imagen de la app de tarjeta de cumplea帽os desde este v铆nculo.
2. Haz clic en Descargar.
3. Haz clic con el bot贸n derecho en la imagen y, luego, guarda el archivo en tu computadora como androidparty.png.
4. Toma nota de d贸nde guardaste la imagen.
5. En Android Studio, haz clic en View > Tool Windows > Resource Manager o en la pesta帽a Resource Manager junto a la ventana Project.
6. Haz clic en + (Add resources to the module) > Import Drawables.
7. En el navegador de archivos, selecciona el archivo de imagen que descargaste y haz clic en Open.
8. Android Studio te muestra una vista previa de la imagen. Selecciona Density en la lista desplegable QUALIFIER TYPE. En una secci贸n posterior, aprender谩s por qu茅 lo haces.
9. Selecciona No Density en la lista VALUE.
10. Haz clic en Siguiente.
11. Android Studio te muestra la estructura de carpetas en la que se ubicar谩 la imagen. Observa la carpeta drawable-nodpi.
12. Haz clic Import(C).
13. Para regresar a la vista de proyectos, haz clic en View > Tool Windows > Project o en la pesta帽a Project del extremo izquierdo
14. Haz clic en app > res > drawable para confirmar que la imagen se encuentra en la carpeta drawable.
15. 
Los dispositivos Android est谩n disponibles en diferentes tama帽os de pantalla (tel茅fonos, tablets y TVs, etc.), y sus pantallas tambi茅n tienen p铆xeles de distintos tama帽os. Es decir, hay dispositivos que tienen 160 p铆xeles por pulgada cuadrada y otros que adaptan 480 p铆xeles en el mismo espacio. Si no tienes en cuenta estas variaciones de densidad de p铆xeles, es posible que el sistema escale tus im谩genes, lo que podr铆a producir que se vean borrosas, im谩genes grandes que consumen demasiada memoria o im谩genes cuyo tama帽o es incorrecto.

Cuando cambias el tama帽o de las im谩genes a uno m谩s grande del que puede controlar el sistema Android, se genera un error de memoria insuficiente. En el caso de las im谩genes de fondo o fotos, como la imagen actual, androidparty.png, debes colocarlas en la carpeta drawable-nodpi, ya que eso detendr谩 el comportamiento de cambio de tama帽o.

Se abrir谩 el di谩logo Import Drawables.
### Resource Manager
Resource Manager es una ventana de herramientas que te permite importar, crear, administrar y usar recursos en tu app.

Android Studio crea una carpeta drawable-nodpi y coloca la imagen en ella. En la vista de proyectos de Android Studio, el nombre del recurso se muestra como androidparty.png (nodpi). En el sistema de archivos de la 
computadora, Android Studio crear铆a una carpeta con el nombre drawable-nodpi.Si la imagen se import贸 correctamente, Android Studio la agregar谩 a la lista en la pesta帽a Drawable. En esa lista se incluyen todos los 铆conos e im谩genes de tu app. Ahora, puedes usar la imagen en tu app.

### Recursos en Jetpack Compose

Los recursos son los archivos adicionales y el contenido est谩tico que usa tu c贸digo, como mapas de bits, strings de interfaz de usuario, instrucciones de animaci贸n, etc. Para obtener m谩s informaci贸n sobre los recursos en Android, consulta Informaci贸n general sobre los recursos de las app.

Siempre debes separar los recursos para apps, como im谩genes y strings, de tu c贸digo para que puedas mantenerlos de forma independiente. En tiempo de ejecuci贸n, Android utiliza el recurso adecuado seg煤n la configuraci贸n actual. Por ejemplo, puedes proporcionar un dise帽o de interfaz de la IU diferente seg煤n el tama帽o de la pantalla o strings diferentes seg煤n la configuraci贸n de idioma.

### C贸mo agrupar recursos

Siempre debes colocar cada tipo de recurso en un subdirectorio espec铆fico del directorio res/ de tu proyecto. Por ejemplo, esta es la jerarqu铆a de archivos de un proyecto simple:
```
MyProject/
    src/
        MyActivity.kt
    res/
        drawable/
            graphic.png
        mipmap/
            icon.png
        values/
            strings.xml
```

Como se ve en este ejemplo, el directorio res/ contiene todos los recursos de los subdirectorios, que incluyen un directorio drawable/ para un recurso de imagen, un directorio mipmap/ para los 铆conos de selector y un directorio values/ para recursos de strings. Para obtener m谩s informaci贸n sobre el uso, el formato y la sintaxis para los recursos de la app, consulta Descripci贸n general de los tipos de recursos.

Acceso a recursos

Jetpack Compose puede acceder a los recursos definidos en tu proyecto de Android. Se puede acceder a los recursos con los ID de recursos que se generan en la clase R de tu proyecto.

### Agrega Dise帽o Box
Los tres elementos de dise帽o est谩ndar b谩sicos en Compose son los elementos Column, Row y Box componibles. Aprendiste sobre los elementos Column y Row componibles en los codelabs anteriores, ahora explorar谩s m谩s sobre el elemento Box componible.
El dise帽o Box es uno de los elementos de dise帽o est谩ndar en Compose. Usa el dise帽o Box para apilar elementos uno sobre el otro. El dise帽o Box tambi茅n te permite configurar la alineaci贸n espec铆fica de los elementos que contiene.

### C贸mo ajustar la escala del contenido
Agregaste la imagen a tu app y la posicionaste. Ahora debes ajustar el tipo de escala de la imagen, que indica c贸mo ajustar el tama帽o de la imagen para que se muestre en pantalla completa.
Hay bastantes tipos de ContentScale disponibles. Usa el escalamiento del par谩metro ContentScale.Crop, que ajusta la escala de la imagen de manera uniforme para mantener la relaci贸n de aspecto, de modo que el ancho y el alto de esta sean iguales o mayores a la dimensi贸n correspondiente de la pantalla.
### Cambia la opacidad
Para mejorar el contraste de la app, cambia la opacidad de la imagen de fondo.
Agrega el par谩metro alpha al elemento componible Image y establ茅celo en 0.5F.
### Modificadores de dise帽o
Los modificadores se usan para decorar o agregar comportamiento a los elementos de IU de Jetpack Compose. Por ejemplo, puedes agregar fondos, padding o comportamiento a filas, texto o botones. Para configurarlos, un elemento componible o un dise帽o debe aceptar un modificador como par谩metro.En un codelab anterior, aprendiste sobre los modificadores y usaste el modificador de padding (Modifier.padding) para agregar espacio alrededor de un Text componible. Los modificadores pueden ser muy 煤tiles, y lo ver谩s en este camino de aprendizaje y en los pr贸ximos.
Para establecer la posici贸n de los elementos secundarios dentro de un Row, configura los argumentos horizontalArrangement y verticalAlignment. Para una Column, configura los argumentos verticalArrangement y horizontalAlignment.La propiedad de las disposiciones se usa para organizar los elementos secundarios cuando el tama帽o del dise帽o es mayor que la suma de sus elementos secundarios.De la misma manera, cuando el tama帽o de Row es mayor que la suma de sus tama帽os secundarios, se puede especificar un horizontalArrangement para definir el posicionamiento de la elementos secundarios dentro de Row. A continuaci贸n, se muestra una ilustraci贸n de diferentes disposiciones horizontales:

### Padding
Un elemento de la IU se une a su contenido. Para evitar que la contracci贸n sea demasiado marcada, puedes especificar una cantidad de padding a cada lado.El padding se usa como modificador, lo que significa que puedes aplicarlo a cualquier elemento componible. Para cada lado del elemento componible, el modificador padding toma un argumento opcional que define la cantidad de padding.
El texto describe el proceso para **extraer *strings* codificadas** en una aplicaci贸n de Android (escrita en Kotlin y Jetpack Compose) a **recursos de *string***. Este es el paso fundamental y m谩s importante para facilitar la traducci贸n de la aplicaci贸n a otros idiomas.

## Resumen del Proceso para Facilitar las Traducciones (Traducci贸n/Localizaci贸n)

Para que tu aplicaci贸n de Android sea f谩cil de traducir a otros idiomas (localizaci贸n), debes **evitar codificar las *strings*** (texto) directamente en el c贸digo. En su lugar, debes **extraerlas a un archivo de recursos** llamado `strings.xml`.

Aqu铆 tienes los pasos clave para hacerlo:

### 1\. Extracci贸n de Strings

1.  **Identifica la String Codificada:** Localiza la *string* que est谩 escrita directamente en tu c贸digo (ej. `"Happy Birthday Sam!"`).
2.  **Usa la Herramienta de Android Studio:**
      * Selecciona la *string* sin las comillas (ej. `Happy Birthday Sam!`).
      * Haz clic en la **bombilla**  (o usa la acci贸n r谩pida).
      * Selecciona la opci贸n **"Extract string resource"**.
3.  **Define el Nombre del Recurso:** En el di谩logo "Extract Resource":
      * Asigna un **Resource name** (nombre del recurso) que sea en **min煤sculas** y use **guiones bajos** (`_`) (ej. `happy_birthday_text`).
      * Verifica que el **Resource Value** sea la *string* correcta.
      * Haz clic en **Aceptar**.

### 2\. Resultados Clave

  * **En el C贸digo (Kotlin/Compose):** La *string* codificada es reemplazada por una llamada a la funci贸n que recupera el recurso:

    ```kotlin
    GreetingImage(
        // Antes: message = "Happy Birthday Sam!",
        message = stringResource(R.string.happy_birthday_text), // Despu茅s
        // ...
    )
    // Nota: Necesitas importar stringResource() de androidx.compose.ui.res
    ```

  * **En el Archivo de Recursos (`app > res > values > strings.xml`):** Android Studio crea autom谩ticamente una entrada para el nuevo recurso.

    ```xml
    <resources>
        <string name="app_name">Happy Birthday</string>
        <string name="happy_birthday_text">Happy Birthday Sam!</string>
        <string name="signature_text">From Emma</string>
    </resources>
    ```

### 3\. El Paso de la Traducci贸n

Una vez que todas las *strings* est谩n centralizadas en `strings.xml` (el archivo por defecto), la **traducci贸n real** (localizaci贸n) se logra creando **archivos de recursos alternativos** para cada idioma:

1.  **Crear Directorios de Idioma:** En el directorio `res`, crea un nuevo directorio llamado, por ejemplo, `values-es` (para espa帽ol).
2.  **Traducir Strings:** Dentro de ese nuevo directorio (`values-es`), crea un archivo `strings.xml`.
3.  **Mantener Nombres, Traducir Valores:** Este nuevo archivo debe contener los **mismos nombres de recursos** (`name="happy_birthday_text"`), pero los valores ser谩n las *strings* traducidas.

Android se encarga de seleccionar el archivo `strings.xml` correcto (ej. el de `values-es` si el dispositivo est谩 en espa帽ol) en tiempo de ejecuci贸n.

### **Resumen Sencillo:**

Para hacer traducciones, **extrae todo el texto de la aplicaci贸n al archivo `strings.xml`** y luego crea versiones traducidas de ese archivo para cada idioma.

### 4 Condicionales
En kotlin tienen el tipico if,if-else,if-else-if-else y when.Este 煤ltimo es como un switch en  java.
Tambi茅n en when los condicionales son  objeto -> respuesta o tambi茅n podemos encontrarnos un else o el operador in que es si se encuentra en el rango in (1..n) -> print("true").Tambi茅n
nos podemos encontrar is para saber si el tipo de dato es adecuado is int --> print("true")


### Programaci贸n orientada a objetos

las clases proporcionan planos a partir de cuales se pueden construir objetos. Un objeto es una instancia de una clase que consiste en datos espec铆ficos de ese objeto. Puedes usar instancias de clase y objetos indistintamente.

Como analog铆a, imagina que construyes una casa. Una clase es similar al plan de dise帽o de un arquitecto, tambi茅n conocido como plano. El plano no es la casa, sino las instrucciones para construirla. La casa es el objeto real que se construye a partir de ese plano.

Al igual que el plano de una casa especifica varias habitaciones, y cada una tiene su propio dise帽o y prop贸sito, cada clase tiene su propio dise帽o y prop贸sito. Para saber c贸mo dise帽ar tus clases, debes familiarizarte con la programaci贸n orientada a objetos (OOP), un framework que te ense帽a a encerrar datos, l贸gica y comportamiento en los objetos.

OOP ayuda a simplificar problemas complejos del mundo real en objetos m谩s peque帽os. Hay cuatro conceptos b谩sicos de OOP, cada uno de los cuales aprender谩s m谩s adelante en este codelab:

   1.  Encapsulamiento. Envuelve las propiedades y los m茅todos relacionados que realizan acciones en esas propiedades en una clase. Por ejemplo, considera tu tel茅fono m贸vil. Encapsula una c谩mara, una pantalla, tarjetas de memoria y varios componentes de hardware y software. No tienes que preocuparte por la forma en que los componentes se conectan de forma interna.
<br>
    2. Abstracci贸n. Es una extensi贸n del encapsulamiento. La idea es ocultar la l贸gica de implementaci贸n interna tanto como sea posible. Por ejemplo, para tomar una foto con tu tel茅fono m贸vil, solo debes abrir la app de la c谩mara, apuntar el tel茅fono hacia la escena que deseas capturar y hacer clic en un bot贸n para capturar la foto. No necesitas saber c贸mo se compila la app de la c谩mara ni c贸mo funciona realmente el hardware de la c谩mara del tel茅fono. En resumen, los mecanismos internos de la aplicaci贸n de c谩mara y la forma en que una c谩mara m贸vil captura las fotos se abstraen para permitirte realizar las tareas importantes.
<br>
    3. Herencia. Permite crear una clase en funci贸n de las caracter铆sticas y el comportamiento de otras clases estableciendo una relaci贸n de superior y secundario. Por ejemplo, hay distintos fabricantes que producen una variedad de dispositivos m贸viles que ejecutan el SO Android, pero la IU de cada uno es diferente. En otras palabras, los fabricantes heredan la funci贸n del SO Android y compilan sus personalizaciones a partir de ella.
<br>
    4. Polimorfismo. La palabra es una adaptaci贸n de la ra铆z griega poly-, que significa muchas, y -morphism, que significa formas. El polimorfismo es la capacidad de usar objetos diferentes de una manera com煤n. Por ejemplo, cuando conectas una bocina Bluetooth a tu tel茅fono m贸vil, este solo necesita saber si hay un dispositivo que puede reproducir audio mediante Bluetooth. Sin embargo, puedes elegir entre una variedad de bocinas Bluetooth, y tu tel茅fono no necesita saber c贸mo trabajar con cada una de ellas a nivel espec铆fico.
<br>


#### Definir una clase
Ejemplo de como se hace
```kotlin
    class SmartDevice {
    // empty body
}

fun main() {
}

```


#### Definir una instancia ejemplo

```kotlin
    fun main() {
    val smartTvDevice = SmartDevice()
}

#### C贸mo se definen metodos en las clases

```kotlin

class SmartDevice {
    fun turnOn() {
        // A valid use case to call the turnOff() method could be to turn off the TV when available power doesn't meet the requirement.
        turnOff()
        ...
    }

    ...
}

```

#### C贸mo se construye un constructor

```kotlin
class SmartDevice(val name: String, val category: String) {

    var deviceStatus = "online"

    fun turnOn() {
        println("Smart device is turned on.")
    }

    fun turnOff() {
        println("Smart device is turned off.")
    }
}


```

#### C贸mo se construye un constructor secundario

```kotlin
class SmartDevice(val name: String, val category: String) {
    var deviceStatus = "online"

    constructor(name: String, category: String, statusCode: Int) : this(name, category) {
        deviceStatus = when (statusCode) {
            0 -> "offline"
            1 -> "online"
            else -> "unknown"
        }
    }
    ...
}
```
#### C贸mo implementar herencia
La palabra open espesifica herencia
<br>

```kotlin
open class SmartDevice(val name: String, val category: String) {

    var deviceStatus = "online"

    open fun turnOn() {
        // function body
    }

    open fun turnOff() {
        // function body
    }
}


```

#### Tipos de relaciones
Relaciones IS-A es una relaci贸n unidireccional
Relaciones HAS-A se conoce como composici贸n.

#### Modificadores

Los modificadores de visibilidad son importantes para lograr el encapsulamiento:

    En una clase, te permiten ocultar tus propiedades y m茅todos para evitar el acceso no autorizado fuera de la clase.
    En un paquete, te permiten ocultar las interfaces y clases para evitar el acceso no autorizado fuera del paquete.

Kotlin ofrece cuatro modificadores de visibilidad:

    public. Es el modificador de visibilidad predeterminado. Permite que la declaraci贸n sea accesible en todas partes. Las propiedades y los m茅todos que deseas usar fuera de la clase se marcan como p煤blicos.
    private. Permite que se pueda acceder a la declaraci贸n en la misma clase o archivo de origen.

Es probable que algunos m茅todos y propiedades solo se usen dentro de la clase, y que no necesariamente quieras que se usen otras clases. Estos m茅todos y propiedades se pueden marcar con el modificador de visibilidad private para garantizar que otra clase no pueda acceder a ellos de forma accidental.

    protected. Hace que la declaraci贸n sea accesible en subclases. Las propiedades y los m茅todos que deseas usar en la clase que los define y las subclases se marcan con el modificador de visibilidad protected.
    internal. Permite que se pueda acceder a la declaraci贸n en el mismo m贸dulo. } El modificador interno es similar al privado, pero puedes acceder a propiedades y m茅todos internos desde fuera de la clase, siempre y cuando lo hagas en el mismo m贸dulo.

#### Delegados de Propiedad

Esta lecci贸n se centra en el uso de Delegados de Propiedad en Kotlin para eliminar el c贸digo duplicado y encapsular la l贸gica de acceso y mutaci贸n de las propiedades (las funciones get y set).

1. Definici贸n de Delegado de Propiedad

Un Delegado de Propiedad es un objeto que toma la responsabilidad de administrar el valor de una propiedad, incluyendo las operaciones que normalmente se har铆an en las funciones accesoras get() y set().

    Sintaxis: Se usa la palabra clave by para "delegar" la gesti贸n de la propiedad a una instancia de una clase delegada:
    Kotlin

    var propiedad: Tipo by ObjetoDelegado

2. El Problema Resuelto (Duplicaci贸n de C贸digo)

Antes de los delegados, la l贸gica para verificar si un valor est谩 dentro de un rango (ej. para speakerVolume, channelNumber, brightnessLevel) se repet铆a en el bloque set de cada propiedad en varias clases (SmartTvDevice y SmartLightDevice).

    Objetivo: Reutilizar esta l贸gica de verificaci贸n de rango en una sola clase delegada.

3. Implementaci贸n del Delegado (RangeRegulator)

Para crear un delegado que maneje una propiedad de tipo var (lectura y escritura), la clase debe implementar la interfaz ReadWriteProperty.

A. La Interfaz Clave: ReadWriteProperty

Esta interfaz es el "contrato" que debe cumplir el delegado. Requiere la implementaci贸n de dos m茅todos:

    getValue(...): Act煤a como la funci贸n get() de la propiedad. Devuelve el valor actual.

    setValue(...): Act煤a como la funci贸n set() de la propiedad. Recibe el nuevo valor y aplica la l贸gica antes de almacenarlo.

B. La Clase RangeRegulator

Se crea una clase gen茅rica que almacena el valor y aplica la l贸gica de rango:
Kotlin

import kotlin.properties.ReadWriteProperty
import kotlin.reflect.KProperty

class RangeRegulator(
    initialValue: Int,
    private val minValue: Int,
    private val maxValue: Int
) : ReadWriteProperty<Any?, Int> {

    // 1. El campo de copia de seguridad real que almacena el valor
    var fieldData = initialValue

    // 2. Implementaci贸n de getValue (act煤a como el 'get')
    override fun getValue(thisRef: Any?, property: KProperty<*>): Int {
        return fieldData
    }

    // 3. Implementaci贸n de setValue (act煤a como el 'set')
    override fun setValue(thisRef: Any?, property: KProperty<*>, value: Int) {
        // L贸gica reutilizable: solo asigna si el valor est谩 en el rango
        if (value in minValue..maxValue) {
            fieldData = value
        }
    }
}

4. Uso del Delegado en las Propiedades

Finalmente, se utiliza el delegado RangeRegulator en las clases SmartTvDevice y SmartLightDevice para delegarle la gesti贸n de las propiedades:
Kotlin

// Antes: Ten铆a que definir el 'set' con la l贸gica de rango aqu铆
// private var speakerVolume: Int = 2 

// Ahora: El delegado RangeRegulator se encarga del 'get' y el 'set' con la l贸gica de rango
private var speakerVolume by RangeRegulator(initialValue = 2, minValue = 0, maxValue = 100)

// Igual para otras propiedades con l贸gica de rango:
private var channelNumber by RangeRegulator(initialValue = 1, minValue = 0, maxValue = 200)

Conclusi贸n: Los Delegados de Propiedad son una herramienta poderosa de Kotlin que promueve la reutilizaci贸n de c贸digo y la abstracci贸n, permitiendo encapsular la l贸gica com煤n (como la validaci贸n de rango) fuera de la clase principal.

#### Funciones como dato

La lecci贸n demuestra que en Kotlin, las funciones no son solo bloques de c贸digo ejecutables; son valores que pueden ser almacenados en variables, pasados como argumentos, y devueltos como resultados de otras funciones.

1.  Las Funciones como Tipo de Datos

En Kotlin, puedes especificar el tipo de una variable o par谩metro como una funci贸n.

    Sintaxis del Tipo de Funci贸n: El tipo se expresa con la forma: (Tipo1, Tipo2, ...) -> TipoDeRetorno

        Los par谩metros de entrada van dentro de los par茅ntesis ().

        La flecha -> separa los par谩metros del tipo de dato que se devuelve.

    Ejemplo Clave:

        Una funci贸n sin par谩metros que no devuelve nada tiene el tipo: () -> Unit.

        Una funci贸n que toma dos Int y devuelve un Int tiene el tipo: (Int, Int) -> Int.

2. Almacenar Funciones en Variables

Puedes declarar una variable y asignarle una expresi贸n lambda (una funci贸n an贸nima) y, opcionalmente, especificar su tipo de funci贸n expl铆citamente:
Kotlin

// Inferencia de tipo: Kotlin infiere que 'trick' es de tipo () -> Unit
val trick = {
    println("No treats!")
}

// Tipo de funci贸n expl铆cito: Se declara el tipo () -> Unit
val treat: () -> Unit = {
    println("Have a treat!")
}

3. Devolver una Funci贸n desde otra Funci贸n

Una funci贸n puede devolver otra funci贸n como su resultado, utilizando la sintaxis de tipo de funci贸n como el tipo de retorno.

    Funci贸n trickOrTreat(): Esta funci贸n utiliza un valor booleano (isTrick) para decidir qu茅 funci贸n devolver谩: trick o treat.
    Kotlin

    fun trickOrTreat(isTrick: Boolean): () -> Unit {
        if (isTrick) {
            return trick // Devuelve la funci贸n 'trick'
        } else {
            return treat // Devuelve la funci贸n 'treat'
        }
    }

    fun main() {
        val treatFunction = trickOrTreat(false) // treatFunction ahora es la funci贸n 'treat'
        treatFunction()                       // Esto ejecuta 'Have a treat!'
    }

4. Pasar una Funci贸n como Argumento (Funciones de Orden Superior)

Las funciones pueden ser pasadas como argumentos a otras funciones, creando Funciones de Orden Superior que permiten personalizar el comportamiento.

    Para lograr esto, se declara un par谩metro de la funci贸n usando la Sintaxis del Tipo de Funci贸n.

    Actualizaci贸n de trickOrTreat(): La lecci贸n actualiza la funci贸n para aceptar una funci贸n como argumento (extraTreat), permitiendo un comportamiento personalizado:
    Kotlin

    // El par谩metro 'extraTreat' es una funci贸n que toma un Int y devuelve un String
    fun trickOrTreat(isTrick: Boolean, extraTreat: (Int) -> String) { 
        // ... (el c贸digo posterior usa este par谩metro)
    }

        Lambda con Par谩metros: Si la funci贸n pasada como argumento (la lambda) tiene par谩metros, estos se nombran y se separan del cuerpo con una flecha -> (ej. { nombreParam -> cuerpo }).

El concepto central es que el uso de funciones como tipos de datos permite escribir c贸digo m谩s flexible, modular y reutilizable, un pilar de la programaci贸n funcional en Kotlin.


### Lambda
Las expresiones lambda en Kotlin ofrecen varias formas de escribir c贸digo m谩s conciso y legible, especialmente cuando se utilizan como argumentos de funciones de orden superior.

1. Omitir el Nombre del Par谩metro (Uso Impl铆cito de it)

Cuando una funci贸n lambda tiene un 煤nico par谩metro y no se le proporciona un nombre de forma expl铆cita, Kotlin le asigna impl铆citamente el nombre it.

    Regla: Puedes omitir el nombre del par谩metro y el s铆mbolo ->.

    Sintaxis Original:
    Kotlin

val coins: (Int) -> String = { quantity ->
    "$quantity quarters"
}

Sintaxis Abreviada (usando it):
Kotlin

    val coins: (Int) -> String = {
        "$it quarters" // 'it' se refiere al par谩metro Int
    }

2. Pasar una Expresi贸n Lambda Directamente a una Funci贸n

Las expresiones lambda son literales de funci贸n y, al igual que los literales de String o Int, se pueden pasar directamente como argumentos a la llamada de una funci贸n, eliminando la necesidad de una variable intermedia.

    Concepto: Se pasa la lambda { ... } directamente a la llamada a la funci贸n que la acepta como par谩metro.

    Antes (usando una variable):
    Kotlin

val coins: (Int) -> String = { "$it quarters" }
val treatFunction = trickOrTreat(false, coins)

Ahora (pasando directamente):
Kotlin

    val treatFunction = trickOrTreat(false, { "$it quarters" })

3. Sintaxis de Expresi贸n Lambda al Final (Trailing Lambda)

Cuando el 煤ltimo par谩metro de una funci贸n es un tipo de funci贸n (una lambda), puedes mover la expresi贸n lambda fuera de los par茅ntesis de la llamada a la funci贸n.

    Prop贸sito: Mejora la legibilidad, ya que la l贸gica de la lambda se separa de los dem谩s argumentos.

    Sintaxis Normal:
    Kotlin

val treatFunction = trickOrTreat(false, { "$it quarters" })

Sintaxis de Expresi贸n Lambda al Final:
Kotlin

    val treatFunction = trickOrTreat(false) { "$it quarters" } // La lambda va DESPUS del par茅ntesis de cierre

Esta sintaxis final es muy com煤n en funciones de componibilidad (Composable functions) que se usan para declarar la Interfaz de Usuario (IU) en bibliotecas como Jetpack Compose.

#### Comando repeat
隆Claro! Con gusto te hago un resumen sobre el uso de la funci贸n de orden superior repeat() en Kotlin para ejecutar c贸digo repetidamente, junto con la sintaxis de expresi贸n lambda al final y el uso del par谩metro impl铆cito it.

 Resumen de la Funci贸n de Orden Superior repeat()

Una funci贸n de orden superior es aquella que toma una funci贸n como argumento y/o devuelve una funci贸n. La funci贸n repeat() es un ejemplo conciso de una funci贸n de orden superior proporcionada por Kotlin para realizar un bucle.

Firma de la Funci贸n repeat()

La funci贸n repeat() tiene la siguiente estructura:
Kotlin

repeat(times: Int, action: (Int) -> Unit)

    times: Int: Especifica la cantidad de veces que se debe ejecutar la acci贸n.

    action: (Int) -> Unit: Es la funci贸n lambda que se ejecutar谩 repetidamente.

        Toma un 煤nico par谩metro Int (el 铆ndice de la iteraci贸n, comenzando en 0).

        Devuelve Unit (no devuelve un valor significativo).

Implementaci贸n y Sintaxis

La funci贸n repeat() se utiliza como una alternativa m谩s concisa a un bucle for simple, especialmente cuando no es necesario un bucle for completo.

1. Uso de la Sintaxis Lambda al Final

Como el par谩metro action (el tipo de funci贸n) es el 煤ltimo par谩metro de la funci贸n repeat(), se puede usar la sintaxis de expresi贸n lambda al final (Trailing Lambda):
Kotlin

repeat(4) {
    // C贸digo a repetir
}

2. Omisi贸n del Par谩metro Impl铆cito it

El par谩metro Int de la lambda action es el 铆ndice de la iteraci贸n (0, 1, 2, 3...). Si no necesitas usar este 铆ndice dentro del bloque, puedes omitir por completo su nombre y el s铆mbolo ->. Kotlin le asignar铆a impl铆citamente el nombre it, pero si no se usa, la sintaxis queda simplemente:
Kotlin

repeat(4) {
    // El 铆ndice 'it' existe, pero no se usa aqu铆.
    treatFunction()
}

C贸digo Final Actualizado

Al aplicar repeat(4) con la sintaxis lambda al final y mover la llamada a treatFunction() dentro del bloque de acci贸n, el c贸digo logra que la acci贸n se ejecute cuatro veces:
Kotlin

fun main() {
    val treatFunction = trickOrTreat(false) { "$it quarters" }
    val trickFunction = trickOrTreat(true, null)
    
    // Repite la acci贸n de 'treatFunction()' 4 veces
    repeat(4) { 
        treatFunction()
    }
    
    trickFunction()
}

El resultado de la ejecuci贸n es que la cadena "Have a treat!" se imprime cuatro veces seguidas, antes de que se ejecute la llamada final a trickFunction():

5 quarters
Have a treat!
Have a treat!
Have a treat!
Have a treat!
No treats!

