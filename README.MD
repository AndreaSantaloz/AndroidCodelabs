
# Android Studio y Kotlin
# Propietaria
Andrea Santana L칩pez
## Kotlin playground
https://play.kotlinlang.org/
## Bases de Programaci칩n y Comienzos de Kotlin
Un programa como una serie de instrucciones para que una computadora o un dispositivo m칩vil realicen una acci칩n, como mostrar un mensaje a un usuario o calcular el costo de los art칤culos en un carrito de compras. Las instrucciones paso a paso para lo que la computadora debe hacer se llama c칩digo.Para escribir y editar tu c칩digo, debes usar una herramienta llamada editor de c칩digo para los codelabs se usar치 un editor de c칩digo interactivo llamado Playground de Kotlin
El primer programa que todo inform치tico hace es imprimir "Hola mundo" por lo que primero que ver칠 es como realizar un "Hola Mundo" en Kotlin.
```
fun main() {
    println("Hello, world!!!")
}
```
Aqu칤 tenemos una funci칩n llamada main que utiliza el comando println para mostrar el mensaje en la consola de comandos "CMD" en windows CLI en Linux/Mac.
## 쯈u칠 es Kotlin?
Podemos decir que kotlin es un lenguaje compilado ya que necesita un compilador
## Recomendaciones de estilo de Kotlin
A continuaci칩n, se incluyen algunas de las recomendaciones de la gu칤a de estilo para lo que aprendiste en Kotlin hasta el momento:

Los nombres de las funciones deben seguir la convenci칩n de may칰sculas mediales y deben ser verbos o frases verbales.
Cada sentencia debe estar en su propia l칤nea.
La llave de apertura debe aparecer al final de la l칤nea donde comienza la funci칩n.
Debe haber un espacio antes de la llave de apertura.
El cuerpo de la funci칩n debe tener una sangr칤a de 4 espacios. No uses caracteres de tabulaci칩n para aplicar sangr칤a al c칩digo. Escribe 4 espacios.
La llave de cierre se encuentra en su propia l칤nea despu칠s de la 칰ltima l칤nea de c칩digo del cuerpo de la funci칩n. La llave de cierre debe alinearse con la palabra clave fun al comienzo de la funci칩n.

## Variables
En la programaci칩n inform치tica, existe el concepto de variable, que es un contenedor para un 칰nico dato. Puedes visualizarla como una caja que contiene un valor. Esa caja tiene una etiqueta, que es el nombre de la variable. Si te refieres a la caja por su nombre, tendr치s acceso al valor que contiene.
### Tipos de variables
!["Tipo de datos"](./images/Datas.png)
Existe tambi칠n un tipo llamado null

### 쮺칩mo defines una variable?
Cuando defines una variable, le asignas un nombre para identificarla de manera 칰nica. Tambi칠n debes decidir qu칠 tipo de datos puede contener mediante la especificaci칩n del tipo de datos. Por 칰ltimo, puedes proporcionar un valor inicial que se almacenar치 en la variable, pero es opcional.
### Declaraci칩n de una variable como ejemplo
```
val count: Int = 2
```

Para declarar variables anulables se le pone al tipo un interrogante al lado por ejemplo --> var favoriteActor: String? = "Sandra Oh"
## 쮺칩mo se comenta?
Utlizando dos barras diagonales (//) como comentario simple y /**/ como comentario de m치s de una l칤nea
## 쯈u칠 es una funci칩n?
Una funci칩n es un segmento del programa que realiza una tarea espec칤fica. Tu programa podr칤a tener una o m치s funciones.
Estas son las partes clave necesarias para definir una funci칩n:
                                                                1. La funci칩n necesita un nombre para que puedas llamarla m치s tarde.
                                                                2. Tambi칠n puede requerir algunas entradas o informaci칩n que se debe proporcionar cuando se la llama. 
                                                                   La funci칩n usa estas entradas para lograr su prop칩sito. Pedir entradas es opcional, y algunas funciones no las piden.
                                                                3. La funci칩n tambi칠n tiene un cuerpo que contiene las instrucciones para realizar la tarea.

## Ejercicios del tutorial de kotlin de funciones y convenciones de estilo
1. [Ejercicios Kotlin](./CodelabTutorialKotlin/EjerciciosKotlin.kt)
2. [Conceptos b치sicos Kotlin](./CodelabTutorialKotlin/ConceptosBasicos.kt)

## 쯈u칠 es jetpackCompose?
Jetpack Compose es un kit de herramientas moderno para crear IUs de Android. Compose simplifica y acelera el desarrollo de IUs en Android con menos c칩digo, herramientas potentes y capacidades intuitivas de Kotlin. Con Compose, puedes compilar tu IU a partir de la definici칩n de un conjunto de funciones, llamadas funciones de componibilidad, que toman datos y describen elementos de la IU.
Funciones de componibilidad
Las funciones de componibilidad son los componentes b치sicos de una IU en Compose. Una funci칩n de componibilidad cumple con lo siguiente:

1. Describe alguna parte de tu IU.
2. No devuelve nada.
3. Toma informaci칩n y genera lo que se muestra en la pantalla.

### Anotaciones
Las anotaciones son una forma de adjuntar informaci칩n adicional al c칩digo. Esta informaci칩n ayuda a herramientas como el compilador de Jetpack Compose y a otros desarrolladores a comprender el c칩digo de la app.
Para aplicar una anotaci칩n, se agrega un prefijo al nombre (la anotaci칩n) con el car치cter @ al comienzo de la declaraci칩n en la que se har치 la anotaci칩n. Se pueden anotar diferentes elementos de c칩digo, incluidas propiedades, funciones y clases. M치s adelante en el curso, aprender치s sobre las clases.
![Anotaciones](././images/anotaciones.png)
Ejemplo siguiente
```
// Example code, do not copy it over
@Json
val imgSrcUrl: String
@Volatile
private var INSTANCE: AppDatabase? = null
```
Las anotaciones pueden tomar par치metros. Proporcionan informaci칩n adicional a las herramientas que las procesan. Los siguientes son algunos ejemplos de la anotaci칩n @Preview con y sin par치metros.
![Anotaciones](././images/anotacionesconparams.png)
<br>
Ejemplo de anotaciones con parametros
<br>
![Anotaciones](././images/ejemplodeanotaciones.png)

## Funciones de componibilidad
La funci칩n de componibilidad tiene la anotaci칩n @Composable. Todas estas funciones deben tener esta anotaci칩n. La anotaci칩n informa al compilador de Compose que esta funci칩n est치 dise침ada para convertir datos en IU. Te recordamos que un compilador es un programa especial que toma el c칩digo que escribiste, lo analiza l칤nea por l칤nea y lo traduce a algo que la computadora puede comprender (lenguaje autom치tico).Este fragmento de c칩digo es un ejemplo de una funci칩n simple de componibilidad a la que le pasan datos (el par치metro de la funci칩n name) y los usa para renderizar un elemento de texto en la pantalla.
```
@Composable
fun Greeting(name: String) {
    Text(text = "Hello $name!")
}
```
Algunas notas sobre las funciones de componibilidad:

Jetpack Compose se basa en funciones de componibilidad. Estas funciones te permiten definir la IU de tu app de manera program치tica describiendo c칩mo deber칤a verse, en lugar de enfocarse en el proceso de construcci칩n de la IU. Para crear una funci칩n de componibilidad, agrega la anotaci칩n @Composable al nombre de la funci칩n.

Estas funciones pueden aceptar par치metros, que permiten que la l칩gica de la app describa o modifique la IU. En este caso, tu elemento de la IU acepta una String para que pueda saludar al usuario por su nombre.

La funci칩n de Compose que no devuelve nada y lleva la anotaci칩n @Composable DEBE tener un nombre con letra may칰scula inicial (pascal case). Esta es una convenci칩n de nomenclatura seg칰n la cual la primera letra de cada palabra de una palabra compuesta lleva may칰sculas. La diferencia entre este formato y el de may칰sculas mediales (camel case) es que, en el primer caso, todas las palabras se escriben con may칰scula inicial. En el segundo caso, la primera palabra puede estar en cualquiera de las dos opciones.
La funci칩n de Compose tiene las siguientes caracter칤sticas:
DEBE ser un sustantivo: DoneButton().
NO debe ser un verbo ni una frase verbal: DrawTextField().
NO debe ser una preposici칩n convertida en sustantivo: TextFieldWithLink().
NO debe ser un adjetivo: Bright().
NO debe ser un adverbio: Outside().
Los sustantivos PUEDEN estar precedidos por adjetivos descriptivos: RoundIcon().
<br>
Ejemplo de funciones componibles

```
// Do: This function is a descriptive PascalCased noun as a visual UI element
@Composable
fun FancyButton(text: String) {}


// Do: This function is a descriptive PascalCased noun as a non-visual element
// with presence in the composition
@Composable
fun BackButtonHandler() {}


// Don't: This function is a noun but is not PascalCased!
@Composable
fun fancyButton(text: String) {}


// Don't: This function is PascalCased but is not a noun!
@Composable
fun RenderFancyButton(text: String) {}


// Don't: This function is neither PascalCased nor a noun!
@Composable
fun drawProfileImage(image: ImageAsset) {}
```
## Panel Design de Android Studio
Android Studio te permite obtener una vista previa de las funciones de componibilidad dentro del IDE, en lugar de instalar la app en un emulador o dispositivo Android. Como aprendiste en la ruta de aprendizaje anterior, puedes obtener una vista previa de la apariencia de tu app en el panel Design de Android Studio.
La funci칩n de componibilidad debe proporcionar valores predeterminados para cualquier par치metro para obtener una vista previa. Por este motivo, se recomienda no obtener una vista previa de la funci칩n Greeting() directamente. En su lugar, debes agregar otra funci칩n (BirthdayCardPreview() en este caso) que llame a la funci칩n Greeting() con un par치metro adecuado.
```
@Preview(showBackground = true)
@Composable
fun BirthdayCardPreview() {
    HappyBirthdayTheme {
        Greeting("Android")
    }
}

```
## Jerarqu칤a de la IU
La jerarqu칤a de la IU se basa en la contenci칩n, es decir, un componente puede contener uno o m치s componentes. A veces, se usan los t칠rminos superior y secundario. El contexto aqu칤 es que los elementos superiores de la IU contienen elementos secundarios de la IU, los cuales, a su vez, pueden contener elementos secundarios de la IU. En esta secci칩n, aprender치s sobre los elementos componibles Column, Row y Box, que pueden actuar como elementos superiores de la IU.Los tres elementos de dise침o est치ndar b치sicos en Compose son los elementos Column, Row y Box componibles. En el siguiente codelab, obtendr치s m치s informaci칩n sobre el elemento Box componible.Column, Row y Box son funciones de componibilidad, y toman contenido de este tipo como argumentos, por lo que puedes colocar elementos dentro de estos componentes de dise침o. Por ejemplo, cada elemento secundario dentro de un elemento Row que admite composici칩n se coloca de forma horizontal uno al lado del otro en una fila.
![Jerarqu칤aUI](././images/JerarquiaUI.png)
```
// Don't copy.
Row {
    Text("First Column")
    Text("Second Column")
}
```
Estos elementos de texto se muestran uno al lado del otro en la pantalla, como se ve en esta imagen.

Los bordes azules son solo para fines de demostraci칩n y no se mostrar치n.
![Jerarqu칤aUI](././images/JerarquiaUI2.png)

## Sintaxis de expresi칩n lambda final
En el fragmento de c칩digo anterior, observa que se usan llaves en lugar de par칠ntesis en la funci칩n de componibilidad Row. Esto se llama sintaxis de expresi칩n lambda final. M치s adelante en el curso, aprender치s sobre las lambdas y la sintaxis de expresi칩n lambda final en detalle. Por ahora, familiar칤zate con esta sintaxis de Compose de uso general.

Kotlin ofrece una sintaxis especial para pasar funciones como par치metros a funciones cuando el 칰ltimo par치metro es una funci칩n.
![lambda](././images/lambda.png)
Cuando pasas una funci칩n como ese par치metro, puedes usar la sintaxis de expresi칩n lambda final. En lugar de colocar la funci칩n dentro de los par칠ntesis, puedes colocarla fuera de los par칠ntesis y entre llaves. Esta pr치ctica es recomendada y com칰n en Compose, por lo que debes familiarizarte con la apariencia del c칩digo.

Por ejemplo, el 칰ltimo par치metro en la funci칩n de componibilidad Row() es el par치metro content, una funci칩n que describe los elementos secundarios de la IU. Supongamos que deseas crear una fila que contenga tres elementos de texto. Este c칩digo funcionar칤a, pero es muy engorroso usar el par치metro con nombre para la expresi칩n lambda final:
```
Row(
    content = {
        Text("Some text")
        Text("Some more text")
        Text("Last text")
    }
)
```
Como el par치metro content es el 칰ltimo de la firma de la funci칩n y pasas su valor como una expresi칩n lambda (por ahora, no hay problema si no sabes qu칠 es una lambda; solo familiar칤zate con la sintaxis), puedes quitar el par치metro content y los par칠ntesis de la siguiente manera:
```
Row {
    Text("Some text")
    Text("Some more text")
    Text("Last text")
}
```
Apartado de inserci칩n de imagen y bases de compose  para 25/10/2025
Apartado de crear app de tarjetas desde 25/10 a 26/10

## C칩mo agregar una imagen a tu proyecto

En esta tarea, descargar치s una imagen de Internet y la agregar치s a la app de Happy Birthday.
1. Abre la imagen de la app de tarjeta de cumplea침os desde este v칤nculo.
2. Haz clic en Descargar.
3. Haz clic con el bot칩n derecho en la imagen y, luego, guarda el archivo en tu computadora como androidparty.png.
4. Toma nota de d칩nde guardaste la imagen.
5. En Android Studio, haz clic en View > Tool Windows > Resource Manager o en la pesta침a Resource Manager junto a la ventana Project.
6. Haz clic en + (Add resources to the module) > Import Drawables.
7. En el navegador de archivos, selecciona el archivo de imagen que descargaste y haz clic en Open.
8. Android Studio te muestra una vista previa de la imagen. Selecciona Density en la lista desplegable QUALIFIER TYPE. En una secci칩n posterior, aprender치s por qu칠 lo haces.
9. Selecciona No Density en la lista VALUE.
10. Haz clic en Siguiente.
11. Android Studio te muestra la estructura de carpetas en la que se ubicar치 la imagen. Observa la carpeta drawable-nodpi.
12. Haz clic Import(C).
13. Para regresar a la vista de proyectos, haz clic en View > Tool Windows > Project o en la pesta침a Project del extremo izquierdo
14. Haz clic en app > res > drawable para confirmar que la imagen se encuentra en la carpeta drawable.
15. 
Los dispositivos Android est치n disponibles en diferentes tama침os de pantalla (tel칠fonos, tablets y TVs, etc.), y sus pantallas tambi칠n tienen p칤xeles de distintos tama침os. Es decir, hay dispositivos que tienen 160 p칤xeles por pulgada cuadrada y otros que adaptan 480 p칤xeles en el mismo espacio. Si no tienes en cuenta estas variaciones de densidad de p칤xeles, es posible que el sistema escale tus im치genes, lo que podr칤a producir que se vean borrosas, im치genes grandes que consumen demasiada memoria o im치genes cuyo tama침o es incorrecto.

Cuando cambias el tama침o de las im치genes a uno m치s grande del que puede controlar el sistema Android, se genera un error de memoria insuficiente. En el caso de las im치genes de fondo o fotos, como la imagen actual, androidparty.png, debes colocarlas en la carpeta drawable-nodpi, ya que eso detendr치 el comportamiento de cambio de tama침o.

Se abrir치 el di치logo Import Drawables.
### Resource Manager
Resource Manager es una ventana de herramientas que te permite importar, crear, administrar y usar recursos en tu app.

Android Studio crea una carpeta drawable-nodpi y coloca la imagen en ella. En la vista de proyectos de Android Studio, el nombre del recurso se muestra como androidparty.png (nodpi). En el sistema de archivos de la 
computadora, Android Studio crear칤a una carpeta con el nombre drawable-nodpi.Si la imagen se import칩 correctamente, Android Studio la agregar치 a la lista en la pesta침a Drawable. En esa lista se incluyen todos los 칤conos e im치genes de tu app. Ahora, puedes usar la imagen en tu app.

### Recursos en Jetpack Compose

Los recursos son los archivos adicionales y el contenido est치tico que usa tu c칩digo, como mapas de bits, strings de interfaz de usuario, instrucciones de animaci칩n, etc. Para obtener m치s informaci칩n sobre los recursos en Android, consulta Informaci칩n general sobre los recursos de las app.

Siempre debes separar los recursos para apps, como im치genes y strings, de tu c칩digo para que puedas mantenerlos de forma independiente. En tiempo de ejecuci칩n, Android utiliza el recurso adecuado seg칰n la configuraci칩n actual. Por ejemplo, puedes proporcionar un dise침o de interfaz de la IU diferente seg칰n el tama침o de la pantalla o strings diferentes seg칰n la configuraci칩n de idioma.

### C칩mo agrupar recursos

Siempre debes colocar cada tipo de recurso en un subdirectorio espec칤fico del directorio res/ de tu proyecto. Por ejemplo, esta es la jerarqu칤a de archivos de un proyecto simple:
```
MyProject/
    src/
        MyActivity.kt
    res/
        drawable/
            graphic.png
        mipmap/
            icon.png
        values/
            strings.xml
```

Como se ve en este ejemplo, el directorio res/ contiene todos los recursos de los subdirectorios, que incluyen un directorio drawable/ para un recurso de imagen, un directorio mipmap/ para los 칤conos de selector y un directorio values/ para recursos de strings. Para obtener m치s informaci칩n sobre el uso, el formato y la sintaxis para los recursos de la app, consulta Descripci칩n general de los tipos de recursos.

Acceso a recursos

Jetpack Compose puede acceder a los recursos definidos en tu proyecto de Android. Se puede acceder a los recursos con los ID de recursos que se generan en la clase R de tu proyecto.

### Agrega Dise침o Box
Los tres elementos de dise침o est치ndar b치sicos en Compose son los elementos Column, Row y Box componibles. Aprendiste sobre los elementos Column y Row componibles en los codelabs anteriores, ahora explorar치s m치s sobre el elemento Box componible.
El dise침o Box es uno de los elementos de dise침o est치ndar en Compose. Usa el dise침o Box para apilar elementos uno sobre el otro. El dise침o Box tambi칠n te permite configurar la alineaci칩n espec칤fica de los elementos que contiene.

### C칩mo ajustar la escala del contenido
Agregaste la imagen a tu app y la posicionaste. Ahora debes ajustar el tipo de escala de la imagen, que indica c칩mo ajustar el tama침o de la imagen para que se muestre en pantalla completa.
Hay bastantes tipos de ContentScale disponibles. Usa el escalamiento del par치metro ContentScale.Crop, que ajusta la escala de la imagen de manera uniforme para mantener la relaci칩n de aspecto, de modo que el ancho y el alto de esta sean iguales o mayores a la dimensi칩n correspondiente de la pantalla.
### Cambia la opacidad
Para mejorar el contraste de la app, cambia la opacidad de la imagen de fondo.
Agrega el par치metro alpha al elemento componible Image y establ칠celo en 0.5F.
### Modificadores de dise침o
Los modificadores se usan para decorar o agregar comportamiento a los elementos de IU de Jetpack Compose. Por ejemplo, puedes agregar fondos, padding o comportamiento a filas, texto o botones. Para configurarlos, un elemento componible o un dise침o debe aceptar un modificador como par치metro.En un codelab anterior, aprendiste sobre los modificadores y usaste el modificador de padding (Modifier.padding) para agregar espacio alrededor de un Text componible. Los modificadores pueden ser muy 칰tiles, y lo ver치s en este camino de aprendizaje y en los pr칩ximos.
Para establecer la posici칩n de los elementos secundarios dentro de un Row, configura los argumentos horizontalArrangement y verticalAlignment. Para una Column, configura los argumentos verticalArrangement y horizontalAlignment.La propiedad de las disposiciones se usa para organizar los elementos secundarios cuando el tama침o del dise침o es mayor que la suma de sus elementos secundarios.De la misma manera, cuando el tama침o de Row es mayor que la suma de sus tama침os secundarios, se puede especificar un horizontalArrangement para definir el posicionamiento de la elementos secundarios dentro de Row. A continuaci칩n, se muestra una ilustraci칩n de diferentes disposiciones horizontales:

### Padding
Un elemento de la IU se une a su contenido. Para evitar que la contracci칩n sea demasiado marcada, puedes especificar una cantidad de padding a cada lado.El padding se usa como modificador, lo que significa que puedes aplicarlo a cualquier elemento componible. Para cada lado del elemento componible, el modificador padding toma un argumento opcional que define la cantidad de padding.
El texto describe el proceso para **extraer *strings* codificadas** en una aplicaci칩n de Android (escrita en Kotlin y Jetpack Compose) a **recursos de *string***. Este es el paso fundamental y m치s importante para facilitar la traducci칩n de la aplicaci칩n a otros idiomas.

## Resumen del Proceso para Facilitar las Traducciones (Traducci칩n/Localizaci칩n)

Para que tu aplicaci칩n de Android sea f치cil de traducir a otros idiomas (localizaci칩n), debes **evitar codificar las *strings*** (texto) directamente en el c칩digo. En su lugar, debes **extraerlas a un archivo de recursos** llamado `strings.xml`.

Aqu칤 tienes los pasos clave para hacerlo:

### 1\. Extracci칩n de Strings

1.  **Identifica la String Codificada:** Localiza la *string* que est치 escrita directamente en tu c칩digo (ej. `"Happy Birthday Sam!"`).
2.  **Usa la Herramienta de Android Studio:**
      * Selecciona la *string* sin las comillas (ej. `Happy Birthday Sam!`).
      * Haz clic en la **bombilla** 游눠 (o usa la acci칩n r치pida).
      * Selecciona la opci칩n **"Extract string resource"**.
3.  **Define el Nombre del Recurso:** En el di치logo "Extract Resource":
      * Asigna un **Resource name** (nombre del recurso) que sea en **min칰sculas** y use **guiones bajos** (`_`) (ej. `happy_birthday_text`).
      * Verifica que el **Resource Value** sea la *string* correcta.
      * Haz clic en **Aceptar**.

### 2\. Resultados Clave

  * **En el C칩digo (Kotlin/Compose):** La *string* codificada es reemplazada por una llamada a la funci칩n que recupera el recurso:

    ```kotlin
    GreetingImage(
        // Antes: message = "Happy Birthday Sam!",
        message = stringResource(R.string.happy_birthday_text), // Despu칠s
        // ...
    )
    // Nota: Necesitas importar stringResource() de androidx.compose.ui.res
    ```

  * **En el Archivo de Recursos (`app > res > values > strings.xml`):** Android Studio crea autom치ticamente una entrada para el nuevo recurso.

    ```xml
    <resources>
        <string name="app_name">Happy Birthday</string>
        <string name="happy_birthday_text">Happy Birthday Sam!</string>
        <string name="signature_text">From Emma</string>
    </resources>
    ```

### 3\. El Paso de la Traducci칩n

Una vez que todas las *strings* est치n centralizadas en `strings.xml` (el archivo por defecto), la **traducci칩n real** (localizaci칩n) se logra creando **archivos de recursos alternativos** para cada idioma:

1.  **Crear Directorios de Idioma:** En el directorio `res`, crea un nuevo directorio llamado, por ejemplo, `values-es` (para espa침ol).
2.  **Traducir Strings:** Dentro de ese nuevo directorio (`values-es`), crea un archivo `strings.xml`.
3.  **Mantener Nombres, Traducir Valores:** Este nuevo archivo debe contener los **mismos nombres de recursos** (`name="happy_birthday_text"`), pero los valores ser치n las *strings* traducidas.

Android se encarga de seleccionar el archivo `strings.xml` correcto (ej. el de `values-es` si el dispositivo est치 en espa침ol) en tiempo de ejecuci칩n.

### **Resumen Sencillo:**

Para hacer traducciones, **extrae todo el texto de la aplicaci칩n al archivo `strings.xml`** y luego crea versiones traducidas de ese archivo para cada idioma.

### 4 Condicionales
En kotlin tienen el tipico if,if-else,if-else-if-else y when.Este 칰ltimo es como un switch en  java.
Tambi칠n en when los condicionales son  objeto -> respuesta o tambi칠n podemos encontrarnos un else o el operador in que es si se encuentra en el rango in (1..n) -> print("true").Tambi칠n
nos podemos encontrar is para saber si el tipo de dato es adecuado is int --> print("true")


### Programaci칩n orientada a objetos

las clases proporcionan planos a partir de cuales se pueden construir objetos. Un objeto es una instancia de una clase que consiste en datos espec칤ficos de ese objeto. Puedes usar instancias de clase y objetos indistintamente.

Como analog칤a, imagina que construyes una casa. Una clase es similar al plan de dise침o de un arquitecto, tambi칠n conocido como plano. El plano no es la casa, sino las instrucciones para construirla. La casa es el objeto real que se construye a partir de ese plano.

Al igual que el plano de una casa especifica varias habitaciones, y cada una tiene su propio dise침o y prop칩sito, cada clase tiene su propio dise침o y prop칩sito. Para saber c칩mo dise침ar tus clases, debes familiarizarte con la programaci칩n orientada a objetos (OOP), un framework que te ense침a a encerrar datos, l칩gica y comportamiento en los objetos.

OOP ayuda a simplificar problemas complejos del mundo real en objetos m치s peque침os. Hay cuatro conceptos b치sicos de OOP, cada uno de los cuales aprender치s m치s adelante en este codelab:

   1.  Encapsulamiento. Envuelve las propiedades y los m칠todos relacionados que realizan acciones en esas propiedades en una clase. Por ejemplo, considera tu tel칠fono m칩vil. Encapsula una c치mara, una pantalla, tarjetas de memoria y varios componentes de hardware y software. No tienes que preocuparte por la forma en que los componentes se conectan de forma interna.
<br>
    2. Abstracci칩n. Es una extensi칩n del encapsulamiento. La idea es ocultar la l칩gica de implementaci칩n interna tanto como sea posible. Por ejemplo, para tomar una foto con tu tel칠fono m칩vil, solo debes abrir la app de la c치mara, apuntar el tel칠fono hacia la escena que deseas capturar y hacer clic en un bot칩n para capturar la foto. No necesitas saber c칩mo se compila la app de la c치mara ni c칩mo funciona realmente el hardware de la c치mara del tel칠fono. En resumen, los mecanismos internos de la aplicaci칩n de c치mara y la forma en que una c치mara m칩vil captura las fotos se abstraen para permitirte realizar las tareas importantes.
<br>
    3. Herencia. Permite crear una clase en funci칩n de las caracter칤sticas y el comportamiento de otras clases estableciendo una relaci칩n de superior y secundario. Por ejemplo, hay distintos fabricantes que producen una variedad de dispositivos m칩viles que ejecutan el SO Android, pero la IU de cada uno es diferente. En otras palabras, los fabricantes heredan la funci칩n del SO Android y compilan sus personalizaciones a partir de ella.
<br>
    4. Polimorfismo. La palabra es una adaptaci칩n de la ra칤z griega poly-, que significa muchas, y -morphism, que significa formas. El polimorfismo es la capacidad de usar objetos diferentes de una manera com칰n. Por ejemplo, cuando conectas una bocina Bluetooth a tu tel칠fono m칩vil, este solo necesita saber si hay un dispositivo que puede reproducir audio mediante Bluetooth. Sin embargo, puedes elegir entre una variedad de bocinas Bluetooth, y tu tel칠fono no necesita saber c칩mo trabajar con cada una de ellas a nivel espec칤fico.
<br>


#### Definir una clase
Ejemplo de como se hace
```kotlin
    class SmartDevice {
    // empty body
}

fun main() {
}

```
